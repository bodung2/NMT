<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¨¹ì´ì‚¬ìŠ¬ ë§Œë“¤ê¸° - ë¦¬ë”ë³´ë“œ</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for better typography -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the activity */
        body {
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none; /* Disable default touch actions like pinch-zoom on mobile */
        }
        .organism {
            cursor: grab;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, opacity 0.3s;
        }
        .organism:active {
            cursor: grabbing;
            transform: scale(1.1);
            z-index: 1000;
        }
        #ecosystem-canvas {
            background-color: #E2F0D9;
            background-image:
                linear-gradient(to right, #A9D18E 1px, transparent 1px),
                linear-gradient(to bottom, #A9D18E 1px, transparent 1px);
            background-size: 40px 40px;
            position: relative;
            overflow: hidden;
            border: 2px solid #A9D18E;
        }
        .placed-organism {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            border: 2px solid transparent;
            user-select: none; /* Prevent text selection while dragging */
        }
        .placed-organism.selected {
            border-color: #F59E0B; /* Amber color for selection */
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.7);
        }
        .score-feedback {
            position: absolute;
            font-weight: bold;
            font-size: 1.5rem; /* 24px */
            pointer-events: none;
            transition: all 1s ease-out;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen">

    <!-- Header Section -->
    <header class="bg-white shadow-md p-4 z-20 flex justify-between items-center">
        <div class="flex-1">
            <h1 class="text-2xl font-bold text-green-700">ì¸í„°ë™í‹°ë¸Œ ë¨¹ì´ì‚¬ìŠ¬ & ë¨¹ì´ê·¸ë¬¼ ë§Œë“¤ê¸°</h1>
            <p class="text-gray-600 mt-1">ìœ ê¸°ì²´ë¥¼ ì˜¤ë¥¸ìª½ ìƒíƒœê³„ë¡œ ë“œë˜ê·¸í•œ í›„, í´ë¦­í•˜ì—¬ ì—°ê²°í•´ë³´ì„¸ìš”!</p>
        </div>
        <div class="flex items-center space-x-6 pr-4">
            <div id="user-id-display" class="text-sm font-semibold text-gray-500">ì‚¬ìš©ì ID: <span></span></div>
            <div id="level-display" class="text-xl font-bold text-gray-700">ë ˆë²¨ 1</div>
            <div id="score-display" class="text-2xl font-bold text-blue-600">ì ìˆ˜: 0</div>
        </div>
    </header>

    <!-- Main Content Area -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Organism Bank (Sidebar) -->
        <aside class="w-1/4 lg:w-1/5 bg-gray-200 p-4 overflow-y-auto shadow-lg z-10">
            <h2 class="text-lg font-semibold mb-4 border-b pb-2 text-gray-700">ìœ ê¸°ì²´ ëª©ë¡</h2>
            <div id="organism-bank" class="grid grid-cols-2 gap-4">
                <!-- Organisms will be dynamically injected here by JavaScript -->
            </div>
        </aside>

        <!-- Ecosystem Canvas -->
        <main class="flex-1 relative">
            <div id="ecosystem-canvas" class="w-full h-full"></div>
            <svg id="arrow-svg" class="absolute top-0 left-0 w-full h-full pointer-events-none z-0">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#333" />
                    </marker>
                </defs>
            </svg>
            <div class="absolute bottom-4 right-4 z-10 flex space-x-2">
                <button id="show-leaderboard-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300">
                    ë¦¬ë”ë³´ë“œ ë³´ê¸°
                </button>
                <button id="reset-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300">
                    ì´ˆê¸°í™”
                </button>
            </div>
        </main>
    </div>

    <!-- Modal for level completion -->
    <div id="level-complete-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-2xl text-center transform transition-all scale-95 opacity-0">
            <h2 id="modal-title" class="text-3xl font-bold text-green-600 mb-4">ë ˆë²¨ í´ë¦¬ì–´!</h2>
            <p id="modal-message" class="text-gray-700 mb-6">ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•˜ì„¸ìš”.</p>
            <button id="next-level-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300">
                ë‹¤ìŒ ë ˆë²¨
            </button>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-2xl text-center w-full max-w-lg transform transition-all scale-95 opacity-0">
            <h2 class="text-3xl font-bold text-green-600 mb-4">ë¦¬ë”ë³´ë“œ</h2>
            <div class="flex justify-between items-center text-sm font-semibold text-gray-600 mb-2">
                <span>ìˆœìœ„</span>
                <span>ì‚¬ìš©ì ID</span>
                <span>ì ìˆ˜</span>
            </div>
            <ul id="leaderboard-list" class="space-y-2 text-left">
                <!-- Leaderboard items will be injected here -->
            </ul>
            <button id="close-leaderboard-button" class="mt-6 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300">
                ë‹«ê¸°
            </button>
        </div>
    </div>

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDocs, addDoc, collection, query, orderBy, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Initialization
        // ì´ ë¶€ë¶„ì€ Canvas í™˜ê²½ì—ì„œ ìë™ìœ¼ë¡œ ì œê³µë˜ëŠ” ì „ì—­ ë³€ìˆ˜(__firebase_config, __app_id)ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.
        // ì´ ë³€ìˆ˜ë“¤ì€ ì‚¬ìš©ìì—ê²Œ ë³´ì´ì§€ ì•Šì§€ë§Œ, ë°±ê·¸ë¼ìš´ë“œì—ì„œ Firebase í”„ë¡œì íŠ¸ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
        setLogLevel('debug');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        let userId = null;

        document.addEventListener('DOMContentLoaded', () => {
            const organismBank = document.getElementById('organism-bank');
            const ecosystemCanvas = document.getElementById('ecosystem-canvas');
            const arrowSvg = document.getElementById('arrow-svg');
            const resetButton = document.getElementById('reset-button');
            const scoreDisplay = document.getElementById('score-display');
            const levelDisplay = document.getElementById('level-display');
            const modal = document.getElementById('level-complete-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const nextLevelButton = document.getElementById('next-level-button');
            const showLeaderboardButton = document.getElementById('show-leaderboard-button');
            const leaderboardModal = document.getElementById('leaderboard-modal');
            const leaderboardList = document.getElementById('leaderboard-list');
            const closeLeaderboardButton = document.getElementById('close-leaderboard-button');
            const userIdDisplay = document.getElementById('user-id-display').querySelector('span');
            
            // --- DATA ---
            const levels = [
                { // Level 1: Basic Forest
                    organisms: [
                        { id: 'grass', name: 'í’€', emoji: 'ğŸŒ¾', type: 'producer' },
                        { id: 'carrot', name: 'ë‹¹ê·¼', emoji: 'ğŸ¥•', type: 'producer' },
                        { id: 'rabbit', name: 'í† ë¼', emoji: 'ğŸ‡', type: 'primary-consumer', eats: ['grass', 'carrot'] },
                        { id: 'fox', name: 'ì—¬ìš°', emoji: 'ğŸ¦Š', type: 'secondary-consumer', eats: ['rabbit'] },
                        { id: 'mushroom', name: 'ë²„ì„¯', emoji: 'ğŸ„', type: 'decomposer', eats: ['*'] },
                    ],
                },
                { // Level 2: More complex web
                    organisms: [
                        { id: 'grass', name: 'í’€', emoji: 'ğŸŒ¾', type: 'producer' },
                        { id: 'mouse', name: 'ì¥', emoji: 'ğŸ', type: 'primary-consumer', eats: ['grass'] },
                        { id: 'rabbit', name: 'í† ë¼', emoji: 'ğŸ‡', type: 'primary-consumer', eats: ['grass'] },
                        { id: 'snake', name: 'ë±€', emoji: 'ğŸ', type: 'secondary-consumer', eats: ['mouse'] },
                        { id: 'eagle', name: 'ë…ìˆ˜ë¦¬', emoji: 'ğŸ¦…', type: 'tertiary-consumer', eats: ['mouse', 'rabbit', 'snake'] },
                    ],
                },
                { // Level 3: Savanna
                    organisms: [
                        { id: 'acacia', name: 'ì•„ì¹´ì‹œì•„', emoji: 'ğŸŒ³', type: 'producer' },
                        { id: 'zebra', name: 'ì–¼ë£©ë§', emoji: 'ğŸ¦“', type: 'primary-consumer', eats: ['acacia'] },
                        { id: 'gazelle', name: 'ê°€ì ¤', emoji: 'ğŸ¦Œ', type: 'primary-consumer', eats: ['acacia'] },
                        { id: 'lion', name: 'ì‚¬ì', emoji: 'ğŸ¦', type: 'secondary-consumer', eats: ['zebra', 'gazelle'] },
                        { id: 'vulture', name: 'ë…ìˆ˜ë¦¬', emoji: 'ğŸ¦…', type: 'decomposer', eats: ['*'] },
                    ],
                }
            ];

            // --- STATE MANAGEMENT ---
            let placedOrganisms = {};
            let connections = [];
            let startNode = null;
            let instanceCounter = 0;
            let score = 0;
            let currentLevelIndex = 0;
            let totalCorrectConnectionsInLevel = 0;
            let madeCorrectConnections = new Set(); // To avoid duplicate counting
            let isUserAuthenticated = false;

            // Firebase Authentication
            async function initializeAuth() {
                try {
                    // í™˜ê²½ ë³€ìˆ˜ __initial_auth_tokenì´ ìˆì„ ê²½ìš° ì»¤ìŠ¤í…€ í† í°ìœ¼ë¡œ ë¡œê·¸ì¸ ì‹œë„
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token.length > 0) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        // ì—†ì„ ê²½ìš° ìµëª… ë¡œê·¸ì¸
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Authentication failed:", error);
                }
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // ì¸ì¦ ì„±ê³µ ì‹œ ì‚¬ìš©ì ID ì„¤ì •
                    userId = user.uid;
                    userIdDisplay.textContent = userId;
                    isUserAuthenticated = true;
                }
            });

            // Firestore Functions
            async function saveScore() {
                if (!isUserAuthenticated) {
                    console.warn("User not authenticated. Score not saved.");
                    return;
                }
                try {
                    // ê³µê°œ ë­í‚¹ ë°ì´í„°ë¥¼ ì €ì¥í•  ê²½ë¡œë¥¼ ì„¤ì •
                    const scoresCollection = collection(db, `artifacts/${appId}/public/data/scores`);
                    await addDoc(scoresCollection, {
                        userId: userId,
                        score: score,
                        timestamp: serverTimestamp() // Firestore ì„œë²„ ì‹œê°„ì„ ì‚¬ìš©í•´ ì •í™•í•œ ìˆœìœ„ë¥¼ ë§¤ê¹ë‹ˆë‹¤.
                    });
                    console.log("Score saved successfully!");
                } catch (error) {
                    console.error("Error saving score:", error);
                }
            }
            
            async function getLeaderboard() {
                try {
                    const scoresCollection = collection(db, `artifacts/${appId}/public/data/scores`);
                    // ì ìˆ˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬í•˜ì—¬ ìƒìœ„ 10ê°œ ë¬¸ì„œë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¿¼ë¦¬
                    const q = query(scoresCollection, orderBy("score", "desc"), limit(10));
                    const querySnapshot = await getDocs(q);
                    const leaderboard = [];
                    querySnapshot.forEach((doc) => {
                        leaderboard.push(doc.data());
                    });
                    return leaderboard;
                } catch (error) {
                    console.error("Error fetching leaderboard:", error);
                    return [];
                }
            }

            function renderLeaderboard(leaderboardData) {
                leaderboardList.innerHTML = '';
                if (leaderboardData.length === 0) {
                    leaderboardList.innerHTML = '<li class="text-center text-gray-500">ë¦¬ë”ë³´ë“œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.</li>';
                    return;
                }

                leaderboardData.forEach((entry, index) => {
                    const listItem = document.createElement('li');
                    listItem.className = `flex justify-between items-center p-2 rounded-md ${index % 2 === 0 ? 'bg-gray-100' : 'bg-white'}`;
                    listItem.innerHTML = `
                        <span class="font-bold text-lg">${index + 1}.</span>
                        <span class="text-xs break-all">${entry.userId}</span>
                        <span class="font-semibold text-blue-600">${entry.score}ì </span>
                    `;
                    leaderboardList.appendChild(listItem);
                });
            }

            // --- GAME LOGIC ---
            function loadLevel(levelIndex) {
                // Clear everything
                ecosystemCanvas.innerHTML = '';
                organismBank.innerHTML = '';
                arrowSvg.innerHTML = `<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#333" /></marker></defs>`;
                
                // Reset state
                placedOrganisms = {};
                connections = [];
                startNode = null;
                instanceCounter = 0;
                madeCorrectConnections.clear();
                
                // Load level data
                const levelData = levels[levelIndex];
                populateBank(levelData.organisms);
                
                // Calculate total possible connections for this level (excluding decomposers)
                totalCorrectConnectionsInLevel = levelData.organisms
                    .filter(org => org.eats && org.eats[0] !== '*')
                    .reduce((sum, org) => sum + org.eats.length, 0);

                // Update UI
                levelDisplay.textContent = `ë ˆë²¨ ${levelIndex + 1}`;
                updateScoreDisplay();
                hideModal();
            }

            function populateBank(organismsForLevel) {
                organismsForLevel.forEach(org => {
                    const orgEl = document.createElement('div');
                    orgEl.className = 'organism flex flex-col items-center p-2 bg-white rounded-lg shadow-md hover:shadow-lg';
                    orgEl.draggable = true;
                    orgEl.dataset.id = org.id;
                    orgEl.innerHTML = `<span class="text-4xl">${org.emoji}</span><span class="text-sm font-medium mt-1">${org.name}</span>`;
                    orgEl.addEventListener('dragstart', handleDragStart);
                    organismBank.appendChild(orgEl);
                });
            }

            function handleDragStart(e) {
                if (e.target.draggable === false) {
                    e.preventDefault();
                    return;
                }
                e.dataTransfer.setData('text/plain', e.target.closest('.organism').dataset.id);
            }

            ecosystemCanvas.addEventListener('dragover', e => e.preventDefault());

            ecosystemCanvas.addEventListener('drop', e => {
                e.preventDefault();
                const originalId = e.dataTransfer.getData('text/plain');
                const bankEl = organismBank.querySelector(`.organism[data-id='${originalId}']`);
                if (!bankEl || bankEl.draggable === false) return;
                
                const organismData = levels[currentLevelIndex].organisms.find(org => org.id === originalId);
                if (organismData) {
                    createOrganismOnCanvas(organismData, e.clientX, e.clientY);
                    bankEl.classList.add('opacity-40', 'cursor-not-allowed');
                    bankEl.draggable = false;
                }
            });
            
            function createOrganismOnCanvas(orgData, clientX, clientY) {
                const instanceId = `instance_${instanceCounter++}`;
                const rect = ecosystemCanvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                const placedEl = document.createElement('div');
                placedEl.id = instanceId;
                placedEl.className = 'placed-organism flex flex-col items-center';
                placedEl.dataset.originalId = orgData.id;
                placedEl.innerHTML = `<span class="text-4xl pointer-events-none">${orgData.emoji}</span><span class="text-sm font-medium mt-1 pointer-events-none">${orgData.name}</span>`;
                
                ecosystemCanvas.appendChild(placedEl);
                
                const elWidth = placedEl.offsetWidth;
                const elHeight = placedEl.offsetHeight;
                const finalX = x - elWidth / 2;
                const finalY = y - elHeight / 2;

                placedEl.style.left = `${finalX}px`;
                placedEl.style.top = `${finalY}px`;

                placedOrganisms[instanceId] = { el: placedEl, data: orgData, x: finalX + elWidth / 2, y: finalY + elHeight / 2 };
                placedEl.addEventListener('click', handleOrganismClick);
                makeElementDraggable(placedEl);
            }

            function handleOrganismClick(e) {
                const clickedEl = e.currentTarget;
                if (!startNode) {
                    startNode = clickedEl;
                    startNode.classList.add('selected');
                } else {
                    if (startNode !== clickedEl) {
                        const connectionKey = `${startNode.id}->${clickedEl.id}`;
                        if (!connections.some(c => c.id === connectionKey)) {
                            const preyNodeInfo = placedOrganisms[startNode.id];
                            const predatorNodeInfo = placedOrganisms[clickedEl.id];
                            const preyId = preyNodeInfo.data.id;
                            const predatorData = predatorNodeInfo.data;
                            const isDecomposer = predatorData.eats && predatorData.eats[0] === '*';
                            const isCorrect = isDecomposer || (predatorData.eats && predatorData.eats.includes(preyId));
                            
                            if (isCorrect) {
                                score += 100;
                                showScoreFeedback('+100', predatorNodeInfo.el, 'correct');
                                const newConnection = { id: connectionKey, from: startNode.id, to: clickedEl.id };
                                connections.push(newConnection);
                                drawArrow(newConnection);

                                if (!madeCorrectConnections.has(connectionKey) && !isDecomposer) {
                                    madeCorrectConnections.add(connectionKey);
                                    if (madeCorrectConnections.size >= totalCorrectConnectionsInLevel) {
                                        setTimeout(levelComplete, 500);
                                    }
                                }
                            } else {
                                score -= 50;
                                showScoreFeedback('-50', predatorNodeInfo.el, 'incorrect');
                            }
                            updateScoreDisplay();
                        }
                    }
                    if(startNode) {
                        startNode.classList.remove('selected');
                        startNode = null;
                    }
                }
            }

            function levelComplete() {
                currentLevelIndex++;
                if (currentLevelIndex < levels.length) {
                    showModal('ë ˆë²¨ í´ë¦¬ì–´!', `ì´ì : ${score}ì . ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•˜ì„¸ìš”.`, 'ë‹¤ìŒ ë ˆë²¨');
                } else {
                    saveScore();
                    showModal('ì¶•í•˜í•©ë‹ˆë‹¤!', `ëª¨ë“  ë ˆë²¨ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤! ìµœì¢… ì ìˆ˜: ${score}ì . ë¦¬ë”ë³´ë“œë¥¼ í™•ì¸í•´ë³´ì„¸ìš”.`, 'ë‹¤ì‹œ ì‹œì‘');
                }
            }
            
            nextLevelButton.addEventListener('click', () => {
                if (currentLevelIndex >= levels.length) {
                    currentLevelIndex = 0; // Restart game
                    score = 0;
                }
                loadLevel(currentLevelIndex);
            });

            resetButton.addEventListener('click', () => {
                score = 0;
                loadLevel(currentLevelIndex);
            });

            showLeaderboardButton.addEventListener('click', async () => {
                showLeaderboardModal();
            });

            closeLeaderboardButton.addEventListener('click', () => {
                hideLeaderboardModal();
            });

            // --- UI AND DRAWING (UNCHANGED and HELPER functions) ---
            ecosystemCanvas.addEventListener('click', (e) => { if (e.target === ecosystemCanvas && startNode) { startNode.classList.remove('selected'); startNode = null; } });
            function updateScoreDisplay() { scoreDisplay.textContent = `ì ìˆ˜: ${score}`; }
            function showModal(title, message, buttonText) {
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                nextLevelButton.textContent = buttonText;
                modal.classList.remove('hidden');
                setTimeout(() => modal.querySelector('div').classList.remove('scale-95', 'opacity-0'), 10);
            }
            function hideModal() {
                modal.querySelector('div').classList.add('scale-95', 'opacity-0');
                setTimeout(() => modal.classList.add('hidden'), 200);
            }
            function showLeaderboardModal() {
                leaderboardModal.classList.remove('hidden');
                getLeaderboard().then(renderLeaderboard);
                setTimeout(() => leaderboardModal.querySelector('div').classList.remove('scale-95', 'opacity-0'), 10);
            }
            function hideLeaderboardModal() {
                leaderboardModal.querySelector('div').classList.add('scale-95', 'opacity-0');
                setTimeout(() => leaderboardModal.classList.add('hidden'), 200);
            }
            function showScoreFeedback(text, targetElement, type) { const feedbackEl = document.createElement('div'); feedbackEl.textContent = text; feedbackEl.className = 'score-feedback'; feedbackEl.style.color = type === 'correct' ? '#16A34A' : '#DC2626'; const targetRect = targetElement.getBoundingClientRect(); const canvasRect = ecosystemCanvas.getBoundingClientRect(); feedbackEl.style.left = `${targetRect.left - canvasRect.left + targetRect.width / 2 - 20}px`; feedbackEl.style.top = `${targetRect.top - canvasRect.top}px`; feedbackEl.style.opacity = '1'; ecosystemCanvas.appendChild(feedbackEl); setTimeout(() => { feedbackEl.style.transform = 'translateY(-50px)'; feedbackEl.style.opacity = '0'; }, 50); setTimeout(() => { feedbackEl.remove(); }, 1050); }
            function drawArrow(connection) { const fromNode = placedOrganisms[connection.from]; const toNode = placedOrganisms[connection.to]; if (!fromNode || !toNode) return; const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.id = connection.id; line.setAttribute('x1', fromNode.x); line.setAttribute('y1', fromNode.y); line.setAttribute('x2', toNode.x); line.setAttribute('y2', toNode.y); line.setAttribute('stroke', '#333'); line.setAttribute('stroke-width', '2'); line.setAttribute('marker-end', 'url(#arrowhead)'); arrowSvg.appendChild(line); }
            function updateArrowsForNode(nodeId) { const node = placedOrganisms[nodeId]; if (!node) return; connections.forEach(conn => { const line = document.getElementById(conn.id); if (!line) return; if (conn.from === nodeId) { line.setAttribute('x1', node.x); line.setAttribute('y1', node.y); } if (conn.to === nodeId) { line.setAttribute('x2', node.x); line.setAttribute('y2', node.y); } }); }
            function makeElementDraggable(element) { let isDragging = false, offsetX, offsetY; const onMouseDown = (e) => { if (startNode) return; e.preventDefault(); isDragging = true; const rect = element.getBoundingClientRect(); offsetX = e.clientX - rect.left; offsetY = e.clientY - rect.top; element.style.zIndex = 100; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); }; const onMouseMove = (e) => { if (!isDragging) return; e.preventDefault(); const canvasRect = ecosystemCanvas.getBoundingClientRect(); let newX = e.clientX - canvasRect.left - offsetX; let newY = e.clientY - canvasRect.top - offsetY; newX = Math.max(0, Math.min(newX, canvasRect.width - element.offsetWidth)); newY = Math.max(0, Math.min(newY, canvasRect.height - element.offsetHeight)); element.style.left = `${newX}px`; element.style.top = `${newY}px`; const nodeData = placedOrganisms[element.id]; nodeData.x = newX + element.offsetWidth / 2; nodeData.y = newY + element.offsetHeight / 2; updateArrowsForNode(element.id); }; const onMouseUp = () => { isDragging = false; element.style.zIndex = 'auto'; document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); }; element.addEventListener('mousedown', onMouseDown); }
            
            // --- START THE APP ---
            initializeAuth();
            loadLevel(currentLevelIndex);
        });
    </script>
</body>
</html>
